# 目录
基础：
- 并发控制
	- 读写锁
	- 锁粒度
- 事务
	- 事务的隔离级别
- 多版本并发控制MVCC

优化MySQL：
- 索引
- 分区
- 复制

经验之谈，MySQL查询优化：
- 通过MySQL的架构分析如何优化查询

# 基础
## 存储引擎
**MySQL逻辑架构:**

- 通用服务层：连接管理，安全性等
- MySQL服务层：和引擎无关的功能（跨存储引擎的功能），包括  查询解析，分析，缓存 / 内置函数，优化器等
- 引擎层：数据的存储和提取（类比操作系统中的文件系统）。上一层通过API和引擎通信，用来真正的执行SQL语句（MySQL服务层解析SQL语句并请求引擎提供的API）

不同存储引擎保存数据和索引的方式不同

## 锁和并发控制
- 并发控制
	- 读写锁
	- 锁粒度
- 事务
	- 事务的隔离级别
- 多版本并发控制MVCC

### 读写锁
最普通的那种，读锁（共享锁）和写锁（排他锁）
处理并发读和写的时候，通过锁来解决问题

**锁粒度：**
- 行锁和表锁（都有共享和排他锁）  
- 为什么需要多种锁粒度？
	- 在**锁的开销**和**安全性**之间实现平衡
	- 表锁：MySQL本身会实现表锁，存储引擎自己也有锁机制。行锁：只有存储引擎来实现（InnoDB有行锁，MyISAM没有）

### MVCC
用于**事务型**存储引擎，存储引擎实现的不是简单的行级锁，可以将MVCC理解为行级锁的变种，但是会减少很多加锁的操作。
具体的实现方式是在每行后保存额外的两列：行的创建时间，行的过期时间（时间指的不是具体时间，而是引擎里记录的每个事务的版本号，每个新的事务都会递增版本号）
仅仅可用于**REPEATABLE READ**和**SERIALIZABLE**的隔离级别
关键词： 某个时间点的**快照** 乐观并发控 悲观并发控制


- SELECT: 只查找版本号更早的行，行的删除版本未定义或更晚 
- INSERT: 保存创建版本号为当前版本号
- DELETE: 保存删除版本号为当前版本号
- UPDATE: 等同于INSERT+DELETE操作

### 意向锁
- 表锁
- 当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。
- 让行锁和表锁能够共存

### 乐观/悲观锁
- 悲观锁：自动提交，每次获取数据都会加锁
- 乐观锁：
	- 版本号
	- CAS算法：比较值A和内存值，相等的话写入新值B

### 事务的特点
ACID 略

### 事务的隔离级别
隔离级别高，不容易出错，但是并发能力会小，开销会高。
- READ UNCOMMITED：很少使用，有脏读问题
- READ COMMITTED：（又叫不可重复读）
- REPEATABLE READ：MySql默认隔离级别，没有脏读问题，同一个事务中每次读操作结果一样。有幻读问题。
- SERIALIZABLE：确保数据的一致性且可以接受没有并发。

Q: 脏读，不可重复读，幻读（没有这些问题称为可串行化 serializable） 
A: 
- 脏读：未提交的事务对其他事务也可见，事务可以读取未提交的数据
- 不可重复读：事务只能读取已提交的数据（某个事务中多次查询可能结果不一样，因为中间有别的事务提交了）
- 幻读：某个事务读取范围时，又有事务插入行，再次查询会出现幻行（**不可重复读主要讲两次查询同一条记录的结果不一样，幻读强调差入和删除**）

Q：可重复读是怎么实现的
A：一个事务在执行过程中可以看到其他事务已经提交的**新**插入的记录（读已经提交的，其实是读早于本事务开始且已经提交的），但是不能看到其他事务对已有记录的更新（即晚于本事务开始的），并且，该事务不要求与其他事务是“可串行化”的。  
通过**行级**共享锁和排他锁可以实现，但是可能出现幻读。
InnoDB使用的方法发是**MVCC并发控制**
在读取事务开始时，系统会给事务一个当前版本号，事务会**读取版本号<=当前版本号的数据**，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。

Q: 如何解决在默认使用可重复读隔离级别时出现的幻读
A: **间隙型锁**，对某一行数据进行操作时，MySQL默认会对周围的行数据进行加锁

# 优化
## 索引
### 索引类型

**从数据结构的角度分：**
- Btree：略
- B+tree：略（聚簇索引是通过B+tree实现的，和非聚簇索引的区别在于聚簇索引叶子节点即数据，保证顺序IO。非聚簇索引叶子节点存储数据的指针）
- hash索引：给每个建立了索引的条目(也可能是好几个联合)条目生成一个hash值和其指向数据位置的指针
	- 不支持范围查询(range query)，只支持精确查询。无法排序。不支持部分索引列匹配（要匹配就要匹配建索引时用的所有列）
	- 特点是比较小，这也是快的原因，可能有冲突但是不太大都不影响性能，冲突特别大影响性能可以通过换hash function来解决
	- 不可用MD5，SHA1这种庞大的hash function。因为生成的hash code很长，查询起来慢

**功能上的区别：**
B或B+tree：全值匹配（和索引中所有列）/匹配最左前缀（索引的第一列）；匹配范围/匹配精确；只访问索引的查询（覆盖索引）
hash：不支持的查询类型见上文。使用场景主要是 ***星型*** schema，需要关联很多查找表（？？？）

Q:使用ORM是否还需要关注索引
A:ORM也需要关心索引，因为ORM只能生成合法的查询，但是不能生成最合适的索引的查询

Q:覆盖索引？
A:只查询建立了索引的列，这个时候查询只访问索引，而不用访问整个数据行

### 补充：B+树维护
- 插入：主要是拆分
- 删除：
TODO：为了优化效率也会又旋转操作？？？

**插入**
![](https://images2015.cnblogs.com/blog/990532/201701/990532-20170117134458755-1356536820.png)

**删除**
![](https://images2015.cnblogs.com/blog/990532/201701/990532-20170117135329114-221553173.png)

### 如何建立高性能索引
**为什么用索引：**
- 快速定位到表的某个位置
- 顺序的索引可以快速ORDER BY,GROUP操作
- 覆盖索引（只需要索引就能完成全部查询）

**为什么有这些优点：**
- 扫描的数据量减少，IO次数减少
- 避免排序和临时表（？？？）
- 随机IO变为顺序IO

不合理的索引需要更多的存储空间/需要更多的维护成本 => 性能反而下降
小表没必要，大表效果好，特大表需要分区

**策略：**
- 索引字符串过长：可以只取前缀建索引（前缀取多少的指标是*索引选择性*）
- 多列索引（联合索引）：
	- 为每个列单独创建索引是愚蠢的
	- 多列索引很重要的一点是优化建立索引的顺序（多列索引按照建索引是SQL语句中的排序来给索引排序），指标也是*索引选择性*，1.一般情况下平均选择性高的排在前面 2.也需要给经常被查询的语句更高的权重
- 去除冗余和重复：索引的维护需要成本，有些代码会重复建立索引（比如设置PRIMARY KEY，UNIQUE和INDEX都会建索引）

**索引在锁机制中的优化：**
- InnoDB会加行锁，索引可以不访问不需要的行，即锁定更少的行
- 减少锁的好处：1. 提高并发性 2. 减少锁造成的开销

Q: 索引选择性?
A: 一个WHERE查询可以对应多少行，选择性高过滤的多（前缀取的越短过滤性肯定越差）

## 复制
### 复制的实现
**为什么复制：**
- 分布式
- 负载均衡
- 备份
- 故障（单点失效）切换

**怎么复制：**
通过**Binary Log**来复制，Binary Log记录的是数据更改的记录，可被翻译成逐条SQL语句
- 主库建立Binary Log，提交事务之前记录事件的更新（按照事务提交顺序）（WAL）
- 备库复制Binary Log到自己的中继日志中并重放事件。**多线程**异步执行。
	- I/O线程和主库连接并复制到**relay log**
	- 二进制转储线程解析Binary Log的线程
	- SQL线程执行复制

### 主从数据库的架构（复制拓扑）
- 异步：master不会管slave的备份进度
	- 可能因为master宕机丢失数据
- 半同步：
	- master保证应答client请求前有至少一个slave写入relay log
	- 仍然有风险：master在等待收到slave的ACK时宕机，可能出现幻读
- 同步：最安全
	- 当slave完成同步以后master才会相应client请求

# 经验之谈：优化数据库查询
## 大家都知道的一些技巧
https://zhuanlan.zhihu.com/p/72855648
- 不能用 select *
- 不使用 NULL 字段
- 合理创建索引
- 为字段选择合适的数据类型

## MySql逻辑架构
![](https://pic4.zhimg.com/80/v2-4d1963141b94fba0b8125dd6a3403153_hd.jpg)
- 客户端层：处理连接，授权认证，安全等
- 服务层：解析，缓存，优化，内置函数（所有跨存储引擎功能）
- 引擎层：提供API：数据存储和提取


## 查询过程
**当我们执行一个查询的时候，MySql做了什么？**

![](https://pic3.zhimg.com/80/v2-3a6399e5da40e092f4029f22725aeb6e_hd.jpg)

**客户端--》查询缓存--》解析--》查询优化--》执行计划（执行引擎）--》返回结果**

**第一步：**
- MySQL客户端/服务端通信协议是“**半双工**”的：
- **客户端**用一个**单独的数据包**将查询请求发送给服务器； **服务器**响应给用户的数据通常会很多，由**多个数据包**组成
	- 所以：尽量保持查询简单且只返回必需的数据，**减小通信间数据包的大小和数量**是一个非常好的习惯，这也是查询中**尽量避免使用SELECT *以及加上LIMIT限制**的原因之一。

**第二步：**
- 如果缓存中有需要的数据，**不执行**之后的步骤
- **写入缓存**和**失效**都消耗资源！
	- 当表结构或数据（例如写操作）变化，缓存失效
- 缓存使用经验：
	- 设计上，小表代替大表
	- 控制缓存空间大小
	- 批量插入代替单条插入

**第三步：解析**
**第四步：查询优化**
- MySql选择的计划其实很可能不是最好的

**第五步：查询执行引擎**
- ``explain + sql`` 语句查看 执行计划
**第六步：返回结果**

## 建立高性能索引
好多。。。是门学问

### 使用覆盖索引：
**如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。**覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：

- 索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量
- 索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多

### 优化冗余和重复索引
### 删除长期未使用索引
### 索引和关联查询
